Stevie, this is a great set of requirements. It gives us a clear path forward for making Q-Status a seriously useful tool. I've taken a look at the existing code and your requests, and I've formulated a phased plan to tackle these improvements. My goal is to build on the solid foundation you've already created, introducing these new features in a logical order that minimizes risk and allows for testing at each stage.

Hereâ€™s the plan I've put together. Let me know what you think.

### **Phase 1: Core Data Enhancements**

This phase focuses on extending the backend data structures and database queries to support the requested features. Getting the data layer right is the critical first step before we touch the UI.

**1. Data Model Updates (`Models.swift`)**

I'll start by updating our core data models to hold the new information we need.

*   **`SessionSummary`:**
    *   Add `lastActivityDate: Date` to track when a session was last active.
    *   Add `cost: Double` to store the calculated cost for the session.
    *   Add `modelId: String?` to enable model-specific pricing.
*   **`GlobalMetrics`:**
    *   Add `tokensToday: Int`, `tokensThisWeek: Int`, `tokensThisMonth: Int`.
    *   Add `costToday: Double`, `costThisWeek: Double`, `costThisMonth: Double`.

**2. Database Reader Enhancements (`QDBReader.swift`)**

Next, I'll modify the `QDBReader` to extract this new information from the database.

*   **Last Activity & Model ID Extraction:**
    *   I'll enhance the main session query to pull the last activity timestamp and model ID from the JSON blob.
    *   **JSON Path Assumption:** I'll assume the last message timestamp can be found at a path like `$.metadata.history[-1].timestamp`. If SQLite's JSON functions don't support negative array indexing, I'll have to parse the history in Swift, but I'll try to keep it in SQL for performance. Similarly, I'll look for the model ID at `$.metadata.model_info.model_id`. We might need to confirm these paths by inspecting a live database.
*   **Efficient Periodic Totals:**
    *   To calculate day/week/month totals without killing performance, I'll implement a snapshot-based approach.
    *   I'll create a new function in `QDBReader` that iterates through all conversations *once* when a database change is detected (via `PRAGMA data_version`).
    *   For each conversation, it will parse the message history and aggregate token counts into daily, weekly, and monthly buckets based on message timestamps.
    *   This avoids re-calculating these expensive metrics on every single UI refresh.

**3. Cost Calculation (`CostEstimator.swift`)**

I'll introduce a new `CostEstimator` service to handle all cost-related calculations.

*   It will define a function: `calculateCost(tokens: Int, modelId: String?) -> Double`.
*   This function will look up the price for the given `modelId` from a dictionary of rates. If not found, it will use a default rate.
*   These rates will be configurable in the app's settings.

**4. Settings (`Settings.swift`)**

I'll add the necessary properties to `Settings.swift` to control the new features.

*   `groupSessionsByFolder: Bool`
*   `showActiveSessionsOnly: Bool`
*   `modelPricing: [String: Double]` (for model-specific rates)
*   `defaultPricePer1kTokens: Double`

---

### **Phase 2: UI and State Management**

With the backend ready, this phase is all about bringing the new features to life in the UI and wiring everything up in the `UpdateCoordinator`.

**1. UI Tweaks (`DropdownView.swift`)**

I'll implement the requested UI improvements.

*   **Wider Dropdown:** I'll change the `.frame()` modifier to give us a width in the 380-420px range.
*   **Path Truncation:** I'll use `.truncationMode(.head)` for the CWD text and add a helper to show the last 2 path components. The full path will be available in a tooltip using `.help()`.
*   **Manual Refresh:** A refresh button will be added to the header, which will directly call a refresh function on the `UpdateCoordinator`.
*   **Filters:** I'll add toggles for "Active last 7 days" and "Group by folder", binding them to the new settings properties.
*   **Persistent Footer:** I'll create a new, always-visible footer view to display the `Today`, `This Week`, and `This Month` metrics from the `GlobalMetrics` object.

**2. State Management (`UpdateCoordinator.swift`)**

I'll update the `UpdateCoordinator` to manage the state for the new UI components.

*   **Filtering & Grouping:** The main `update()` function will be modified to apply the "active sessions" filter and to group sessions by folder if the user has enabled that option. This logic will transform the raw session list from `QDBReader` into the final list displayed by the UI.
*   **Refresh Logic:** I'll implement a public `forceRefresh()` function that bypasses the `data_version` check and unconditionally re-fetches all data from the database.

---

### **Phase 3: Performance and Final Polish**

In the final phase, I'll focus on performance optimization and ensuring we meet the acceptance criteria.

**1. Performance Tuning**

*   **Pagination:** If we find that loading all sessions at once is too slow for users with massive databases, I'll implement pagination. This will involve adding `LIMIT` and `OFFSET` to our SQL queries and updating the UI to load more sessions on scroll.
*   **Caching:** I'll review our caching strategy. The `data_version` check is a good start, but I'll ensure that we're caching the processed and aggregated data (like periodic totals and grouped sessions) to avoid unnecessary re-computation.

**2. Acceptance Criteria**

Before we call this done, we'll need to verify:

*   **Functionality:** All new toggles, filters, and data points (like cost and periodic totals) are present and working correctly.
*   **UI:** The UI is polished, with correct truncation, tooltips, and a wider layout.
*   **Performance:** The app remains snappy and meets our strict performance targets for CPU (<1% idle, <5% update) and memory (<50MB).

This phased approach should allow us to build these features incrementally and ensure a high-quality result. What do you think, Stevie? Are there any adjustments or different priorities you have in mind?
